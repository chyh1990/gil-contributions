BOOST::GIL::IO

1. Overview
2. Tutorial
3. Using IO
4. Reference

1. Overview
-----------
This extension to boost::gil provides an easy to use interface for reading and writing
various image formats. It also includes a framework for adding new formats.

Please see section 3.3 for supported image formats. A basic tutorial is provided 
in section 2.

For adding new image formats please refer to section 3.4.

1.1 Supported Platforms
-----------------------
All platforms supoorted by boost which have a decent C++ compiler. Depending on the  
image format one or more of the following image libraries might be needed:
    * libtiff
    * libjpeg
    * libpng

The library is designed to support as many formats as required by the user.
For instance, if the user only needs bmp support none of the above mentioned 
dependencies are required.

There are more details available in this documentation on the image format dependencies. 
Please see section 3.3.

2. Tutorial
-----------
Thanks to modern C++ programming techniques the interface for this library
is rather small and easy to use. In this tutorial I'll give you a short walkaround 
on how to use this boost::gil extension. For more details please refer to section 3.

Since this is an extension to boost::gil I expect the user to have some very basic
understanding of the gil ( generic image library ). Please see here for the help.

2.1. Header Files
----------------------

Before we can read or write image one thing. The header files to be included all have 
the same format. For instance, tiff_all.hpp will allow to read and write. Whereas, 
tiff_read only allows for reading. If the user only wants to write jpeg's include
jpeg_write.hpp. All formats provide these three types of header files:
    * xxx_all.hpp
    * xxx_read.hpp
    * xxx_write.hpp

xxx stands for image format.

2.2. Reading An Image
----------------------

Probably the most common case to read a tiff image can be done as follows:

std::string filename( "image.tif" );
rgb8_image_t img;
read_image( file, img, tiff_tag() );

The code would be same for all other image formats. The only thing that needs to
change is the tag type ( tiff_tag ) in the read_image call.
The read_image() expects the supplied image type to be compatible with the 
image stored in the file. If the user doesn't know what he is dealing with it
can use read_and_convert_image().
Another important fact is that read_image() will allocate the appropriate
memory needed for the read operation. There are read_view or read_and_convert_view
counterparts, if the memory is already allocated.

Sometimes the user only wants to read a subpart of an image, then the above call
would look as follows:

read_image( filename
          , img
          , image_read_settings< tiff_tag >( point_t( 0, 0 ), point_t( 50, 50 ) )
          );

The image_read_settings class will provide the user with image format independet 
reading setting but can also serves as a pointer for format dependent settings. Please
see the specific image format sections ( 3.3.x ) for more details.

Sometimes, the user is only interested in reading the header information of an image.
Here, the read_image_info() comes into play. 

image_read_info< tiff_t > info = read_image_info( filename
                                                , tiff_t()
                                                );

The image_read_info class keeps all the relevant information that the image header contains.
It's highly image format dependent and though, more information can be found in section 3.3.

2.3. Writing An Image
---------------------

Besides reading the information also writing is the second part of this boost::gil extension.
Writing is a lot simpler than reading since an existing image view contains all the information.
For instance writing an image can be done as follows:

std::string filename( "image.tif" );
rgb8_image_t img( 640, 480 );
... // fill the image with some information
write_view( filename
          , view( img )
          , tiff_tag()
          );

The interface is similar to reading an image. To add image format specific parameter the user can use
image_write_info class. For instance, a user can specify the jpeg quality when writing like this:


std::string filename( "image.jpg" );
rgb8_image_t img( 640, 480 );

// write data into image

write_view( filename
          , view( img )
          , image_write_info< jpeg_tag >( 95 )
          );
          
The above example will write an image where the jpeg quality is set to 95 percent.


3. Using IO
-----------


3.1 Read Interface
------------------

As the Tutorial demonstrated there a few ways to read images. Here is an enumeration of 
all read functions with a short description:

* read_image - read into a gil image with no conversion. Memory is allocated.
* read_view  - read into a gil view with no conversion.

* read_and_convert_image - read and convert into a gil image. Memory is allocated.
* read_and_convert_view  - read and convert into a gil view.

* read_image_info - read the image header.

Conversion in this context is necessary if the source ( file ) is using a incompatible color space
as the destination ( gil image type ). If that's the case the user has to use the xxx_and_convert_xxx
variants.

All functions take the path + filename as the first parameter. This can be anything from a c string, std::string,
std::wstring and a boost::filesystem path. When using the path object the user needs to define 
the ADD_FS_PATH_SUPPORT compiler symbol to include the boost::filesystem dependency.




3.2 Write Interface
-------------------


3.3. Supported Image Formats
----------------------------

3.3.1 BMP
---------

For a general overview of the BMP image file format go to the following link.

http://en.wikipedia.org/wiki/BMP_file_format

Please note, the code has not been tested on X Windows System variations
of the BMP format which are usually referred to XBM and XPM formats.

Here, only the MS Windows and OS/2 format is relevant.

Currently the code is able to read and write the following image types:

Read: gray1_image_t, gray4_image_t, gray8_image_t, rgb8_image_t and, rgba8_image_t
Write: rgb8_image_t and, rgba8_image_t

The lack of having an indexed image type in gil restricts the current interface to only
write out non-indexed images. This is subject to change soon.


3.3.2 JPEG
----------
For a general overview of the JPEG image file format go to the following link.

http://en.wikipedia.org/wiki/JPEG

This jpeg extension is based on the libjpeg library which can be found here:

http://www.ijg.org/

The user has to make sure this library is properly installed. I strongly recommend the user
to build the library yourself. It could potentially save you a lot of trouble.

Currently the code is able to read and write the following image types:

Read: gray8_image_t, rgb8_image_t, cmyk8_image_t
Write: gray8_image_t, rgb8_image_t, cmyk8_image_t

Reading YCbCr or YCCK images is possible but might result in inaccuracies since both color spaces
aren't available yet for gil. For now these color space are read as rgb images.
This is subject to change soon.

3.3.3 PNG
---------
For a general overview of the PNG image file format go to the following link.

http://en.wikipedia.org/wiki/Portable_Network_Graphics

This png extension is based on the libpng, which can be found here:

http://libpng.org/pub/png/libpng.html

The user has to make sure this library is properly installed. I strongly recommend the user
to build the library yourself. It could potentially save you a lot of trouble.

Currently the code is able to read and write the following image types:

Read: gray1, gray2, gray4, gray8, gray16, gray_alpha_8, gray_alpha_16, rgb8, rgb16, rgba8, rgba16
Write: gray1, gray2, gray4, gray8, gray16, gray_alpha_8, gray_alpha_16, rgb8, rgb16, rgba8, rgba16

For reading gray_alpa images the user has to enable the ENABLE_GRAY_ALPHA compiler switch. This color
space is defined in the toolbox by using gray_alpha.hpp.

3.3.4 PNM
---------
For a general overview of the PNM image file format go to the following link.

http://en.wikipedia.org/wiki/Portable_anymap

No external library is needed for the pnm format. Both ascii and binary formats are supported.

Currently the code is able to read and write the following image types:

Read: gray1, gray8, rgb8
Write: gray1, gray8, rgb8

When reading a mono text image the data is read as a gray8 image.

3.3.5 TIFF
----------
For a general overview of the PNM image file format go to the following link.

http://en.wikipedia.org/wiki/Tagged_Image_File_Format

This tiff extension is based on the libtiff, which can be found here:

http://www.remotesensing.org/libtiff/

The user has to make sure this library is properly installed. I strongly recommend the user
to build the library yourself. It could potentially save you a lot of trouble.

TIFF images can virtually encode all kinds of channel sizes representing various color spaces. Even
planar images are possible. For instance, rbg323 or gray7. The channels also can have specific formats, like
integer values or floating point values. For a complete set of options please consult the following websites:

http://www.awaresystems.be/imaging/tiff/tifftags/baseline.html
http://www.awaresystems.be/imaging/tiff/tifftags/extension.html

The author of this extension is not claiming all tiff format are readable or writeable. This extension is
likely to be a moving target adding new features with each new milestone.


3.4 Extending GIL::IO with new Formats
--------------------------------------


4. Reference
------------
