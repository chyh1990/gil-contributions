Reducing the number of template instations in the tiff reader class

Right now, inside the reader we are using templated member functions to avoid a gigantic switch statement. Something like the following:

image_read_info< tiff_tag > _info;

   template< typename View >
   void read_samples_per_pixel( const View& dst_view )
   {
      switch( _info._samples_per_pixel )
      {
         case 1: { read_bits_per_sample< gray_layout_t >( dst_view ); break; }
         case 3: { read_bits_per_sample< rgb_layout_t  >( dst_view ); break; }
         case 4: { read_bits_per_sample< rgba_layout_t >( dst_view ); break; }
      }
   }
   
   template< typename Layout
           , typename View
           >
   void read_bits_per_sample( const View& dst_view )
   {
      switch( _info._bits_per_sample )
      {
         case 1:  { read_sample_format<  1, Layout >( dst_view ); break; }
         case 2:  { read_sample_format<  2, Layout >( dst_view ); break; }
         case 4:  { read_sample_format<  4, Layout >( dst_view ); break; }
         case 8:  { read_sample_format<  8, Layout >( dst_view ); break; }
         case 16: { read_sample_format< 16, Layout >( dst_view ); break; }
         case 32: { read_sample_format< 32, Layout >( dst_view ); break; }
         case 64: { read_sample_format< 64, Layout >( dst_view ); break; }
      }
   }

   template< int      BitsPerSample
           , typename Layout
           , typename View
           >
   void read_sample_format( const View& dst_view )
   {
      switch( _info._sample_format )
      {
         case SAMPLEFORMAT_UINT:   { read_planar< BitsPerSample, SAMPLEFORMAT_UINT, Layout   >( dst_view ); break; }
         case SAMPLEFORMAT_INT:    { read_planar< BitsPerSample, SAMPLEFORMAT_INT, Layout    >( dst_view ); break; }
         case SAMPLEFORMAT_IEEEFP: { read_planar< BitsPerSample, SAMPLEFORMAT_IEEEFP, Layout >( dst_view ); break; }
      }
   }

   template< int      BitsPerSample
           , int      SampleFormat
           , typename Layout
           , typename View
           >
   void read_planar( const View& dst_view )
   {
      typedef pixel_type_factory< BitsPerSample, SampleFormat, Layout >::type pixel_t;

      if( _info._planar_configuration == PLANARCONFIG_CONTIG )
      {
         read_rows_interleaved< image_t >( dst_view
                                         , unspecified_t() );
      }
      else if( _info._planar_configuration == PLANARCONFIG_SEPARATE )
      {
         read_rows_planar< image_t >( dst_view
                                    , unspecified_t() );
      }
   }
   
   
In tiff to describe an image type the following tags can be used. In parenthesis I have given the possible values.

* samples per pixels ( 1, 2, 3, 4, 5 )
* bits per sample ( 1, 2, 4, 6, 8, 10, 12, 14, 16, 24, 32, 64 )
* sample format ( uint, int, float )
* planar configuration ( interleaved, planar )
* photometric interpretation ( rgb, palette, cmyk )

To cut down the parameters and parameter values one can argue that reading rgba and cmyk will most likely result in the same code generated by the compiler. Both colorspaces have the same amount of channels and their channel types are defined by other tiff tags.

Also, dealing with palette images will be done seperately. Another cut down is for supporting planar images. GIL doesn't support planar bit aligned images yet, and though, the bits per sample is 8, 16, 32, and 64.

When reading values, we probably do not really care what specific value type they represent. Weather it's uint, int, or float doesn't matter at this point in time. We have a byte buffer which is of the size of a scanline which will be filled up by TIFFReadScanline.

Which leaves us with three othorgonal tiff_reader parameter. That would describe a memory region which could be cast into a specific image.

For planar images we support:

* samples per pixels ( 1, 2, 3, 4, 5 )
* bits per sample ( 8, 16, 32, 64 )

Interleaved images supports more bits per sample.

* samples per pixels ( 1, 2, 3, 4, 5 )
* bits per sample ( 1, 2, 4, 6, 8, 10, 12, 14, 16, 24, 32, 64 )




For example:

Samples of pixel is 1 which means there are

